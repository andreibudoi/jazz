export const metadata = {
    description: "How to use HTTP requests to communicate with Server Workers using experimental_defineRequest."
};

import { CodeGroup } from "@/components/forMdx";
import { Alert } from "@garden-co/design-system/src/components/atoms/Alert";

# HTTP Requests with Server Workers

HTTP requests are the easiest way to communicate with Server Workers in Jazz. They work well with any framework or runtime that supports standard Request and Response objects, can be scaled horizontally, and put clients and workers in direct communication.

## Setting up HTTP requests

### Defining request schemas

Use `experimental_defineRequest` to define your API schema:

<CodeGroup>
```ts
import { experimental_defineRequest, z } from "jazz-tools";
import { Event, Ticket } from "./schema";

const workerId = process.env.NEXT_PUBLIC_JAZZ_WORKER_ACCOUNT!;

export const bookEventTicket = experimental_defineRequest({
  url: "/api/book-event-ticket",
  workerId,
  // The schema definition of the data we send to the server
  request: {
    schema: {
      event: Event,
    },
    // The data that will be considered as "loaded" in the server input
    resolve: {
      event: { reservations: true },
    },
  },
  // The schema definition of the data we expect to receive from the server
  response: {
    schema: { ticket: Ticket },
    // The data that will be considered as "loaded" in the client response
    // It defines the content that server directly sends to the client, without involving the sync server
    resolve: { ticket: true },
  },
});
```
</CodeGroup>

### Setting up the Server Worker

We need to start a Server Worker instance that will be able to sync data with the sync server, and handle the requests.

<CodeGroup>
```ts
import { startWorker } from "jazz-tools/worker";

export const jazzServer = await startWorker({
  syncServer: "wss://cloud.jazz.tools/?key=your-api-key",
  accountID: process.env.JAZZ_WORKER_ACCOUNT,
  accountSecret: process.env.JAZZ_WORKER_SECRET,
});
```
</CodeGroup>

## Handling requests on the server

### Creating API routes

Create API routes to handle the defined requests. Here's an example using Next.js API routes:

<CodeGroup>
```ts
import { jazzServer } from "@/jazzServer";
import { bookEventTicket, Ticket, Event } from "@/schema";
import { JazzRequestError } from "jazz-tools";

export async function POST(request: Request) {
  return bookEventTicket.handle(
    request,
    jazzServer.worker,
    async ({ event }, madeBy) => {
      const ticketGroup = Group.create(jazzServer.worker);
      const ticket = Ticket.create({
        account: madeBy,
        event,
      });

      // Give access to the ticket to the client
      ticketGroup.addMember(madeBy, "reader");

      event.reservations.push(ticket);

      return {
        ticket,
      };
    },
  );
}
```
</CodeGroup>

## Making requests from the client

### Using the defined API

Make requests from the client using the defined API:

<CodeGroup>
```ts
import { bookEventTicket, Ticket, Event } from "@/schema";
import { isJazzRequestError } from "jazz-tools";

export async function sendEventBookingRequest(event: Event) {
  const { ticket } = await bookEventTicket.send({ event });

  return ticket;
}
```
</CodeGroup>

## Error handling

### Server-side error handling

Use `JazzRequestError` to return proper HTTP error responses:

<CodeGroup>
```ts
import { jazzServer } from "@/jazzServer";
import { bookEventTicket, Ticket, Event } from "@/schema";
import { JazzRequestError } from "jazz-tools";

export async function POST(request: Request) {
  return bookEventTicket.handle(
    request,
    jazzServer.worker,
    async ({ event }, madeBy) => {
      // Check if the event is full
      if (event.reservations.length >= event.capacity) {
        // The JazzRequestError is propagated to the client, use it for any validation errors
        throw new JazzRequestError("Event is full", 400);
      }

      const ticketGroup = Group.create(jazzServer.worker);
      const ticket = Ticket.create({
        account: madeBy,
        event,
      });

      // Give access to the ticket to the client
      ticketGroup.addMember(madeBy, "reader");

      event.reservations.push(ticket);

      return {
        ticket,
      };
    },
  );
}
```
</CodeGroup>

<Alert variant="info" className="mt-4">
  **Note**: To ensure that the limit is correctly enforced, the handler should be deployed in a single worker instance (e.g. a single Cloudflare DurableObject).
  
  Details on how to deploy a single instance Worker are available in the [Deployments & Transactionality](#deployments--transactionality) section.
</Alert>

### Client-side error handling

Handle errors on the client side:

<CodeGroup>
```ts
import { bookEventTicket, Ticket, Event } from "@/schema";
import { isJazzRequestError } from "jazz-tools";

export async function sendEventBookingRequest(event: Event) {
  try {
    const { ticket } = await bookEventTicket.send({ event });

    return ticket;
  } catch (error) {
    // This works as a type guard, so you can easily get the error message and details
    if (isJazzRequestError(error)) {
      alert(error.message);
      return;
    }
  }
}
```
</CodeGroup>

<Alert variant="info" className="mt-4">
  **Note**: The `experimental_defineRequest` API is still experimental and may change in future versions. For production applications, consider the stability implications.
</Alert>

## Deployments & Transactionality

### Single Instance Requirements

Deploy your Server Worker on a single instance when applying validation rules that require atomic operations.

For example, when implementing capacity limits in an event registration system, you need a single instance to ensure the capacity check and ticket creation happen atomically.

Jazz is an eventually consistent database, and with multiple region deployments you may accept multiple registrations at the same time
and realize after the sync that the event is over capacity.

Transactional updates on multi-region deployments are part of the roadmap, but not yet supported.

Examples of when you must deploy on a single instance are:
- when a counter is involved
- when there is any kind of limit on the resources (like capacity)

Essentially when the output of the request depends on the state of the database, you must deploy on a single instance.

### Multi-Region Deployment

When no transactional constraints exist, you can deploy Server Workers across multiple regions for better performance and availability.

Examples of when it's acceptable to deploy across multiple regions are:
- sending emails
- sending notifications
- calling external services (like LLMs)

When the output of the request does not depend on the state of the database, you can deploy across multiple regions.